//! `Identifiable` trait for any Rust data structure that can have an id.

#![cfg_attr(feature = "cargo-clippy", allow(unreadable_literal))]  // To match the look & feel from TL schema


/// Type id of the bool true value.
pub const BOOL_TRUE_ID: u32 = 0x997275b5;
/// Type id of the bool false value.
pub const BOOL_FALSE_ID: u32 = 0xbc799737;
/// Type id of the int type.
pub const INT_ID: u32 = 0xa8509bda;
/// Type id of the long type.
pub const LONG_ID: u32 = 0x22076cba;
/// Type id of the double type.
pub const DOUBLE_ID: u32 = 0x2210c154;
/// Type id of the string type.
pub const STRING_ID: u32 = 0xb5286e24;
/// Type id of the vector type.
pub const VECTOR_ID: u32 = 0x1cb5c415;


/// A trait for a Rust data structure that can have an id.
pub trait Identifiable {
    /// Get id of a value of an identifiable type.
    ///
    /// Its signature is made `(&self) -> i32`, not `() -> i32` because of enum
    /// types where different enum variants can have different ids.
    fn type_id(&self) -> u32;

    /// Get enum variant_hint for a value of an identifiable type.
    ///
    /// This method is purely for assisting `de::Deserializer` to deserialize
    /// enum types because `Deserialize` implementations generated by
    /// `#[derive(Deserialize)]` call `Deserializer::deserialize_identifier()`
    /// to identify an enum variant.
    fn enum_variant_id(&self) -> Option<&'static str>;
}


impl<'a, T: Identifiable> Identifiable for &'a T {
    fn type_id(&self) -> u32 {
        (*self).type_id()
    }

    fn enum_variant_id(&self) -> Option<&'static str> {
        (*self).enum_variant_id()
    }
}

impl<T: Identifiable> Identifiable for Box<T> {
    fn type_id(&self) -> u32 {
        (**self).type_id()
    }

    fn enum_variant_id(&self) -> Option<&'static str> {
        (**self).enum_variant_id()
    }
}

#[cfg_attr(feature = "cargo-clippy", allow(match_bool))]  // match looks better here
impl Identifiable for bool {
    fn type_id(&self) -> u32 {
        match *self {
            false => BOOL_FALSE_ID,
            true => BOOL_TRUE_ID,
        }
    }

    // Doesn't really serve any purpose here, but implement anyway for completeness
    fn enum_variant_id(&self) -> Option<&'static str> {
        match *self {
            false => Some("false"),
            true  => Some("true"),
        }
    }
}


macro_rules! impl_identifiable_for_primitives {
    ($($type:ty => $id_value:expr,)*) => {
        $(
            impl Identifiable for $type {
                fn type_id(&self) -> u32 {
                    $id_value
                }

                fn enum_variant_id(&self) -> Option<&'static str> {
                    None
                }
            }
        )*
    };
}

impl_identifiable_for_primitives! {
    i8  => INT_ID,
    i16 => INT_ID,
    i32 => INT_ID,
    i64 => LONG_ID,

    u8  => INT_ID,
    u16 => INT_ID,
    u32 => INT_ID,
    u64 => LONG_ID,

    f32 => DOUBLE_ID,
    f64 => DOUBLE_ID,

    String => STRING_ID,
}

impl<'a> Identifiable for &'a str {
    fn type_id(&self) -> u32 {
        STRING_ID
    }

    fn enum_variant_id(&self) -> Option<&'static str> {
        None
    }
}

impl<T> Identifiable for Vec<T> {
    fn type_id(&self) -> u32 {
        VECTOR_ID
    }

    fn enum_variant_id(&self) -> Option<&'static str> {
        None
    }
}
